<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Particles Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; position: fixed; width: 100%; height: 100%; font-family: sans-serif; }
        canvas { display: block; touch-action: none; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 12px;
            color: white; width: 140px; backdrop-filter: blur(5px);
        }
        select, input { width: 100%; margin-top: 5px; margin-bottom: 10px; border-radius: 5px; }

        /* Escondemos el video pero lo mantenemos activo */
        #input_video {
            position: absolute; bottom: 10px; right: 10px;
            width: 100px; height: auto; border: 2px solid #00ffcc;
            border-radius: 8px; transform: scaleX(-1);
            z-index: 50; pointer-events: none;
        }
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; z-index: 200; text-align: center;
        }
    </style>
</head>
<body>

    <div id="loading">Cargando IA...<br>Espera un momento</div>

    <div id="ui">
        <label>Forma:</label>
        <select id="shape">
            <option value="heart">Corazón</option>
            <option value="flower">Flor</option>
            <option value="saturn">Saturno</option>
        </select>
        <input type="color" id="color" value="#00ffcc">
    </div>

    <video id="input_video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const loading = document.getElementById('loading');

        // --- ESCENA THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1); // Optimización para móvil
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        const particleCount = 2500; // Reducido para mejor rendimiento móvil
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const targetPos = new Float32Array(particleCount * 3);
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

        const mat = new THREE.PointsMaterial({
            size: 0.04, color: 0x00ffcc, transparent: true, blending: THREE.AdditiveBlending
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // --- GENERADOR DE FORMAS ---
        function setShape(type) {
            for (let i = 0; i < particleCount; i++) {
                let x, y, z = 0;
                const t = Math.random() * Math.PI * 2;
                if (type === 'heart') {
                    x = 16 * Math.pow(Math.sin(t), 3) * 0.1;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.1;
                } else if (type === 'flower') {
                    const r = 1.5 * Math.cos(5 * t);
                    x = r * Math.sin(t); y = r * Math.cos(t);
                } else { // Saturno
                    if (i < particleCount * 0.5) {
                        x = Math.cos(t) * Math.sin(Math.random()*Math.PI) * 1.2;
                        y = Math.sin(t) * Math.sin(Math.random()*Math.PI) * 1.2;
                    } else {
                        const r = 1.8 + Math.random() * 0.5;
                        x = Math.cos(t) * r; y = Math.sin(t) * r * 0.3;
                    }
                }
                targetPos[i*3] = x; targetPos[i*3+1] = y; targetPos[i*3+2] = z;
            }
        }
        setShape('heart');

        // --- CONTROL DE MANOS ---
        let hX = 0, hY = 0, hScale = 1;

        function onResults(results) {
            loading.style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // Seguimiento suavizado
                hX = THREE.MathUtils.lerp(hX, (hand[8].x - 0.5) * -8, 0.2);
                hY = THREE.MathUtils.lerp(hY, (hand[8].y - 0.5) * -8, 0.2);

                // Gesto de escala: Pulgar (4) e Índice (8)
                const dist = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
                hScale = THREE.MathUtils.lerp(hScale, dist * 8, 0.1);
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 480
        });
        cameraFeed.start();

        // --- INTERFAZ ---
        document.getElementById('shape').onchange = (e) => setShape(e.target.value);
        document.getElementById('color').oninput = (e) => mat.color.set(e.target.value);

        // --- RENDER ---
        function animate() {
            requestAnimationFrame(animate);
            const positions = points.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Las partículas se mueven hacia el objetivo (target) influenciadas por la mano
                positions[i3] += (targetPos[i3] * hScale + hX - positions[i3]) * 0.1;
                positions[i3+1] += (targetPos[i3+1] * hScale + hY - positions[i3+1]) * 0.1;
                positions[i3+2] += (targetPos[i3+2] - positions[i3+2]) * 0.1;
            }
            points.geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>